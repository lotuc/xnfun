<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Introduction to xnfun (Cross Node Function)</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-76420995-1', 'auto');
  ga('send', 'pageview');
</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">xnfun</span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="intro.html"><div class="inner"><span>Introduction to xnfun (Cross Node Function)</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>lotuc</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>xnfun</span></div></div></li><li class="depth-3 branch"><a href="lotuc.xnfun.api.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>api</span></div></a></li><li class="depth-3"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></div></li><li class="depth-4 branch"><a href="lotuc.xnfun.core.node.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>node</span></div></a></li><li class="depth-4 branch"><a href="lotuc.xnfun.core.transport.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>transport</span></div></a></li><li class="depth-4"><a href="lotuc.xnfun.core.transport-mqtt.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>transport-mqtt</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#introduction-to-xnfun-cross-node-function" id="introduction-to-xnfun-cross-node-function"></a>Introduction to xnfun (Cross Node Function)</h1>
<p><code>xnfun</code> is designed around the abstraction of node. Consider a node as the container of a group of functions, it manages local &amp; remote function execution states; and nodes are inter-connected through transports.</p>
<p>Checkout the source code at <a href="https://github.com/lotuc/xnfun">lotuc/xnfun</a> and view api documentation at <a href="https://lotuc.org/xnfun">xnfun</a>.</p>
<p>Next we will go through two kinds of functions supported.</p>
<ul>
<li>Unary RPC</li>
<li>Bidirectional RPC</li>
</ul>
<h2><a href="#unary-rpc" id="unary-rpc"></a>Unary RPC</h2>
<p>At present, we only implemented the MQTT transport. So take it as an example.</p>
<p>First, start a MQTT broker.</p>
<pre><code class="language-sh">cat &gt; mosquitto.conf &lt;&lt;EOF
allow_anonymous true
listener 1883
EOF

docker run --rm -it -v `pwd`/mosquitto.conf:/mosquitto/config/mosquitto.conf \
    -p 1883:1883 eclipse-mosquitto

# Now you've started a broker at 1883 which can be connected anonymously.
</code></pre>
<p>Next start a Clojure repl which loads the dependency.</p>
<pre><code class="language-sh">cat &gt; deps.edn &lt;&lt;EOF
{:deps {lotuc.xnfun/xnfun {:git/sha "1d0b91d316260bce3bd5cc04504421b9c48eac3a"
                           :git/url "https://github.com/lotuc/xnfun.git"}}}
EOF

clojure
</code></pre>
<p>From the repl, we start two <code>xnfun</code> nodes and register some functions to each.</p>
<pre><code class="language-clojure">(require '[lotuc.xnfun.api :refer [start-node add-function call]])

(def n0 (start-node {:transport
                     {:xnfun/module 'xnfun.mqtt
                      :mqtt-topic-prefix ""
                      :mqtt-config
                      {:broker "tcp://127.0.0.1:1883"
                       :connect-options {:max-in-flight 1000
                                         :auto-reconnect true}}}}))
;; Actually, the mqtt at 127.0.0.1:1883 is the default transport.
;; We start another node directly.
(def n1 (start-node {}))

;; Register function "add" to n0
(add-function n0 "add" (fn [[a b]] (+ a b)))

;; Register function "sub" to n1
(add-function n1 "sub" (fn [[a b]] (- a b)))

@(call n0 "add" [4 2])
@(call n0 "sub" [4 2])

@(call n1 "add" [4 2])
@(call n1 "sub" [4 2])
</code></pre>
<p>Since the node <code>n0</code> and <code>n1</code> are connected to the same MQTT transport, the tow nodes are actually inter-connected. You can call to each other.</p>
<pre><code class="language-clojure">@(call n0 "sub" [4 2])
@(call n1 "add" [4 2])

;; and sure you can call to the function registered to the node itself
@(call n0 "add" [4 2])
@(call n1 "sub" [4 2])
</code></pre>
<h2><a href="#bidirectional-rpc" id="bidirectional-rpc"></a>Bidirectional RPC</h2>
<p>This mode is like the <a href="https://grpc.io/docs/what-is-grpc/core-concepts/#bidirectional-streaming-rpc">gRPC Bidirectional streaming RPC</a>.</p>
<p>Create a function that supports bidirectional call, now the function got a second argument, you can retieve two channels <code>in-c</code> and <code>out-c</code>. From <code>in-c</code> you can listen for <code>caller</code>â€™s message, and via <code>out-c</code> you can send message to caller. Check <a href="https://lotuc.org/xnfun/lotuc.xnfun.api.html#var-add-function">lotuc.xnfun.api/add-function</a> for details.</p>
<pre><code class="language-clojure">(require '[clojure.core.async :refer [&lt;! go-loop put!]])

(defn echo-server
  [arg {:keys [in-c out-c]
        {:as req-meta :keys [req-id hb-interval-ms]} :req-meta}]
  (let [p (promise)]
    ;; Keep heartbeat.
    (future (loop []
              (put! out-c {:typ :xnfun/hb})
              (when (= :timeout (deref p hb-interval-ms :timeout))
                (recur))))
    (go-loop []
      (when-let [{:keys [typ data] :as d} (&lt;! in-c)]
        (case typ
          :xnfun/cancel
          (deliver p :cancel) ; quit

          :xnfun/to-callee
          (do (put! out-c {:typ :xnfun/to-caller :data data})
              (recur))

          (deliver p {:unkown d}))))
    @p
    arg))
</code></pre>
<p>Register the function to node, say <code>n1</code></p>
<pre><code class="language-clojure">(add-function n1 "echo-server" echo-server)
</code></pre>
<p>Now, try call it from node <code>n0</code></p>
<pre><code class="language-clojure">(require '[lotuc.xnfun.api :refer [call-function]])

(def r (call-function n0 "echo-server" "hello world"
                      {:req-meta {:timeout-ms 3600000
                                  :hb-interval-ms 3000
                                  :hb-lost-ratio 2}}))

;; retrieve channels from the response
(def in-c  (get-in r [:request :in-c]))
(def out-c (get-in r [:request :out-c]))
;; Get the promise waiting for function call result
(def resp (:res-promise r))

;; Setup a go-loop waiting for echo response
(go-loop [{:as v :keys [typ data]} (&lt;! out-c)]
  (if v (do (when (= typ :xnfun/to-caller)
              (println "!!!" data))
            (recur (&lt;! out-c)))
      (println "quit")))

;; Send message to callee
(put! in-c {:typ :xnfun/to-callee :data "hi!"})

;; Stop the function
(put! in-c {:typ :xnfun/cancel :data nil})

;; And check the function call result
@resp
</code></pre>
</div></div></div></body></html>